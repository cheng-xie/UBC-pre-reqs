var TextNode = function(text, position){
    this.color  = createjs.Graphics.getHSL(Math.random()*360, 90, 30);

	this.textObj = new createjs.Text(text, "20px Arial", this.color);
	this.textObj.x = position[0];
	this.textObj.y = position[1];
    
    this.circleObj = new createjs.Shape();
    this.circleObj.graphics.beginFill(this.color).drawCircle(0, 0, 10);
    this.circleObj.x = position[0];
    this.circleObj.y = position[1];
	
	this.movePosition = function(delta){
		this.textObj.x += delta[0];
		this.textObj.y += delta[1];
	    this.circleObj.x += delta[0];
		this.circleObj.y += delta[1];
    };
	
	this.getPosition = function(){
		return [this.textObj.x, this.textObj.y];
	};
	
	this.getTextObj = function(){
		return this.textObj;
	};
    
    this.getCircleObj = function(){
        return this.circleObj;
    };
};

var NodeEdge = function(stage, value, start, end){
	this.value = value;
	this.start = start;
	this.end = end;
	this.lineObj = new createjs.Shape();
	
	if(value != 0){
		this.lineObj = new createjs.Shape();
		this.lineObj.graphics.setStrokeStyle(1);
		this.lineObj.graphics.beginStroke("blue");
		this.lineObj.graphics.moveTo(start.getPosition()[0], start.getPosition()[1]);
		this.lineObj.graphics.lineTo(end.getPosition()[0], end.getPosition()[1]);
		stage.addChild(this.lineObj);
	}
	
	this.getLineObj = function(){
		return this.lineObj;
	};
	
	this.update = function(stage){
		stage.removeChild(this.lineObj);
		this.lineObj = new createjs.Shape();
		this.lineObj.graphics.setStrokeStyle(1);
		this.lineObj.graphics.beginStroke("blue");
		this.lineObj.graphics.moveTo(start.getPosition()[0], start.getPosition()[1]);
		this.lineObj.graphics.lineTo(end.getPosition()[0], end.getPosition()[1]);
		stage.addChild(this.lineObj);
	};
};

var ForceDirectedGraph = function(matrix, stage, node_texts, canvas){
	var REPULSIVE_CONSTANT = 20000;
	var SPRING_CONSTANT = 0.02;
    var BORDER_REPULSION_CONSTANT = 0.02;
	
	//matrix representation of force directed graph, the rows represent the end point of the edges
	var graph_matrix = matrix;
	var nodes = [];
	var edges = [];

    var graphContainer = new createjs.Container();

	this.setup = function (starting_positions){
		for(i = 0; i < node_texts.length; i++){
			var text = new TextNode(node_texts[i], starting_positions[i]);
			nodes.push(text);
			stage.addChild(nodes[nodes.length-1].getTextObj());
	        stage.addChild(nodes[nodes.length-1].getCircleObj());
        }
		for(i = 0; i < node_texts.length; i++){
			for(j = 0; j < node_texts.length; j++){
				if(graph_matrix[i][j] != 0){
					edges.push(new NodeEdge(stage, graph_matrix[i][j], nodes[i], nodes[j]));
				}
			}
		}
	};
	
	this.tic = function (){
		//Perform logic to update the positions of the nodes each tic.
		for(i = 0; i < nodes.length; i++){
			repulse = getRepulsion(i);
			attract = getAttraction(i);
            b_repulse = borderRepulsion(i);
			nodes[i].movePosition([(repulse[0] + attract[0] + b_repulse[0]), (repulse[1] + attract[1] + b_repulse[1])]);
		}
		//update the edges accordingly
		for(i = 0; i < edges.length; i++){
			edges[i].update(stage);
		}
	};
	
	function getRepulsion(node_index){
		/*
		 * The summed repulsion of all the other nodes of the graph.
		 * Repulsion scales with inverse square of the distance between the nodes.
		 */
		delta = [0, 0];
		for(j = 0; j < nodes.length; j++){
			if(j != node_index){
				r = [(nodes[node_index].getPosition()[0]-nodes[j].getPosition()[0]),
					(nodes[node_index].getPosition()[1]-nodes[j].getPosition()[1])];
				h = Math.sqrt(r[0]*r[0] + r[1]*r[1]);
				c = REPULSIVE_CONSTANT/(h*h);
				delta[0] += c*(r[0]/h);
				delta[1] += c*(r[1]/h);
			}
		}
		return delta;
	}
	
	function getAttraction(node_index){
		/*
		 * The summed attraction of all the parent nodes of node_index.
		 * Based on Hooke's law, simple weighted distance.
		 */
		delta = [0, 0];
		for(j = 0; j < nodes.length; j++){
			//only pull this nodes towards its parents
			if(graph_matrix[node_index][j]!=0 || graph_matrix[j][node_index]!=0){
				r = [(nodes[j].getPosition()[0]-nodes[node_index].getPosition()[0]),
					(nodes[j].getPosition()[1]-nodes[node_index].getPosition()[1])];
				c = SPRING_CONSTANT;
				delta[0] += c*r[0];
				delta[1] += c*r[1];
			}
		}
		return delta;
	}
	
	function borderRepulsion(node_index){
		//TODO implement this function
        /*
         * Returns the delta position change generated by the
         * repulsion from the borders of the canvas on this node.
         */
        border_height = canvas.height;
        border_width = canvas.width;
        console.log(border_height)
        delta = [0, 0];
        x_position = nodes[node_index].getPosition()[0];
        y_position = nodes[node_index].getPosition()[1];
        r = [0, 0];
        r[0] = x_position - border_width/2;
        r[1] = y_position - border_height/2;
        console.log(r[0]);
        console.log(r[1]);
        c = BORDER_REPULSION_CONSTANT;
		delta[0] -= c*r[0];
		delta[1] -= c*r[1]*border_width/border_height;
 
        console.log(delta);
        return delta;
    }
};


